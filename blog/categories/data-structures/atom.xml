<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Data-structures | Aschenblog]]></title>
  <link href="http://nick-aschenbach.github.io/blog/categories/data-structures/atom.xml" rel="self"/>
  <link href="http://nick-aschenbach.github.io/"/>
  <updated>2016-01-17T17:41:27-08:00</updated>
  <id>http://nick-aschenbach.github.io/</id>
  <author>
    <name><![CDATA[Nick Aschenbach]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building a Gem for RubyGems.org]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/09/29/building-a-gem-for-rubygems-dot-org/"/>
    <updated>2014-09-29T18:49:06-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/09/29/building-a-gem-for-rubygems-dot-org</id>
    <content type="html"><![CDATA[We are going through some large code refactors at work and are building [rails engines](http://guides.rubyonrails.org/engines.html). This requires creating apps within our main app. Each sub-app resides in its own gem and is typically mounted or consumed in some way by the host application. While I work on several gems for different projects at work, I had never developed one from scratch and submitted it to [RubyGems](http://rubygems.org/). I took some previous work on a [SMS Scrabble cheater app](/blog/2014/07/20/text-messaging-made-easy-with-twilio/) to help motivate the project. 

Developing the skeleton for a gem is extremely easy:

<!-- more -->

&#8220;`
bundle gem foobar
&#8220;`

Several files are created:

&#8220;`
create  foobar/Rakefile
create  foobar/LICENSE.txt
create  foobar/README.md
create  foobar/.gitignore
create  foobar/foobar.gemspec
create  foobar/lib/foobar.rb
create  foobar/lib/foobar/version.rb
Initializing git repo in /Users/sela/workspace/foobar
&#8220;`

Let&#8217;s take a look at the gemspec file:

{% codeblock lang:rb %}
# coding: utf-8
lib = File.expand_path(&#8216;../lib&#8217;, __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)
require &#8216;foobar/version&#8217;

Gem::Specification.new do |spec|
  spec.name          = &#8220;foobar&#8221;
  spec.version       = Foobar::VERSION
  spec.authors       = [&#8220;Nick Aschenbach&#8221;]
  spec.email         = [&#8220;nick.aschenbach@gmail.com&#8221;]
  spec.summary       = %q{TODO: Write a short summary. Required.}
  spec.description   = %q{TODO: Write a longer description. Optional.}
  spec.homepage      = &#8220;&#8221;
  spec.license       = &#8220;MIT&#8221;

  spec.files         = `git ls-files -z`.split(&#8220;\x0&#8221;)
  spec.executables   = spec.files.grep(%r{^bin/}) { |f| File.basename(f) }
  spec.test_files    = spec.files.grep(%r{^(test|spec|features)/})
  spec.require_paths = [&#8220;lib&#8221;]

  spec.add_development_dependency &#8220;bundler&#8221;, &#8220;~> 1.6&#8221;
  spec.add_development_dependency &#8220;rake&#8221;
end
{% endcodeblock %}

Also a handy `README.md` file is created that shows users how to install the gem using bundler. 

&#8220;`
TODO: Write a gem description

## Installation

Add this line to your application&#8217;s Gemfile:

    gem &#8216;foobar&#8217;

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install foobar

## Usage

TODO: Write usage instructions here

## Contributing

1. Fork it ( https://github.com/[my-github-username]/foobar/fork )
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am &#8216;Add some feature&#8217;`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request
&#8220;`

I used this template for my `scrabble_score` gem. The full source code is available on [Github](https://github.com/nick-aschenbach/scrabble-score). The project is extremely simple and has the following structure:

&#8220;`
.
├── Gemfile
├── Gemfile.lock
├── LICENSE.txt
├── README.md
├── assets
│   └── dictionary.txt
├── lib
│   ├── scrabble_score
│   │   ├── dictionary.rb
│   │   ├── letters.rb
│   │   ├── version.rb
│   │   └── word_finder.rb
│   └── scrabble_score.rb
├── scrabble_score.gemspec
└── spec
    ├── assets
    │   └── dictionary.txt
    ├── lib
    │   └── scrabble_score
    │       ├── dictionary_spec.rb
    │       ├── letters_spec.rb
    │       └── word_finder_spec.rb
    └── spec_helper.rb

7 directories, 16 files
&#8220;`

After getting my specs green and playing around with the code a bit, I went to generate the gem. First, let&#8217;s upgrade to the latest RubyGems version:

&#8220;`
gem update &#8211;system
&#8220;`

Now, let&#8217;s build the gem:

&#8220;`
gem build scrabble_score.gemspec
&#8220;`

The first time I ran this tool I received a handful of warnings:

&#8220;`
WARNING:  no homepage specified
WARNING:  open-ended dependency on rspec (>= 0, development) is not recommended
  if rspec is semantically versioned, use:
    add_development_dependency &#8216;rspec&#8217;, &#8216;~> 0&#8217;
WARNING:  open-ended dependency on simplecov (>= 0, development) is not recommended
  if simplecov is semantically versioned, use:
    add_development_dependency &#8216;simplecov&#8217;, &#8216;~> 0&#8217;
WARNING:  See http://guides.rubygems.org/specification-reference/ for help
  Successfully built RubyGem
  Name: scrabble_score
  Version: 0.1.0
  File: scrabble_score-0.1.0.gem
&#8220;`

For the homepage I used the project&#8217;s Github repository. I also added versions to the development dependencies:

&#8220;`
spec.add_development_dependency &#8216;bundler&#8217;, &#8216;~> 1.6&#8217;
spec.add_development_dependency &#8216;rspec&#8217;, &#8216;3.0.0&#8217;
spec.add_development_dependency &#8216;simplecov&#8217;, &#8216;0.9.1&#8217;
&#8220;`

I deleted the `scrabble_score-0.1.0.gem` file and ran the `gem build` command again. Here is the output:

&#8220;`
  Successfully built RubyGem
  Name: scrabble_score
  Version: 0.1.0
  File: scrabble_score-0.1.0.gem
&#8220;`

Everything looks good, so I proceeded with the last step by running:

&#8220;`
gem push scrabble_score-0.1.0.gem 
&#8220;`

Which created the following output:

&#8220;`
Enter your RubyGems.org credentials.
Don&#8217;t have an account yet? Create one at https://rubygems.org/sign_up
   Email:   nick.aschenbach@gmail.com
Password:   

Signed in.
Pushing gem to https://rubygems.org&#8230;
Successfully registered gem: scrabble_score (0.1.0)
&#8220;`

My experience creating a gem for RubyGems was a pleasant one. Please do a quick search to ensure that your gem name is unique before you get started. There are many guides out there for how to write gems. It is a good idea to take a look at one or two of these before getting started.

Happy gem cutting!
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Autocompletion With Tries]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/08/19/super-fast-autocomplete-with-tries/"/>
    <updated>2014-08-19T19:50:17-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/08/19/super-fast-autocomplete-with-tries</id>
    <content type="html"><![CDATA[{% img left /assets/2014-08-19-super-fast-autocomplete-with-tries/images/trie.png 200 auto Trie Graph %} 

Tries (pronounced 'try' or 'trie' as in retrieval) is an ordered data structure often used to store strings. It is a type of tree where the decoration on each node represents the position of the element being stored. If we store a string, then a depth first search of the tree to a leaf node will visit characters that make up that string.

Tries are great for super-fast autocomplete search. A breadth first search from any given point in the tree will find an exact match (if it exists), then matches one character away, then two and so on down the tree.

To build a trie we will need a recursively defined node called `TrieNode`. Let's take a look at some Ruby code that we will use to build a Trie:

<!-- more -->

{% codeblock lang:rb %}
class TrieNode
  def initialize(decoration = &#8216;.&#8217;)
    @decoration = decoration
    @children = {}
  end

  def addLetters(letters)
    addLettersRecursively(letters, letters)
  end

  protected

  def addLettersRecursively(letters, full_word)
    @full_word = full_word and return if letters.size == 0

    first_letter = letters[0]
    @children[first_letter] = TrieNode.new(first_letter) unless @children.has_key?(first_letter)
    @children[first_letter].addLettersRecursively(letters[1..-1], full_word)
  end
end
{% endcodeblock %}

It has a few instance variables including a `decoration` and a `full_word`. We store child relationships by recursively adding new `TrieNodes` in a `children` hash peeling off one letter at a time. I could have used a single method for the recursion, but use a `addLetters` method as a driver for the `addLettersRecursively` method.

Finding a node in the Trie follows the same pattern as adding letters:

{% codeblock lang:rb %}
def findNode(letters)
  return self if letters.size == 0

  return @children[letters[0]].findNode(letters[1..-1]) if @children.has_key?(letters[0])
  nil
end
{% endcodeblock %}

Note that not all nodes in the tree represent member strings that are stored in the Trie. We marked the Trie member nodes with the `full_word` instance variable above. We need the `findNode` method for traversals as we will see in a minute.

Now we can implement the Trie itself. It maintains the root node of the tree and has facilities to insert, membership and search:

{% codeblock lang:rb %}
class Trie
  def initialize(words = [])
    @root_node = TrieNode.new
    words.each { |word| @root_node.addLetters(word) }
  end

  def insert(word)
    @root_node.addLetters(word)
  end

  def contains?(word)
    node = @root_node.findNode(word)

    return true if node and node.word
    false
  end

  def search(letters = &#8221;)
    words = []
    queue = []
    node = @root_node.findNode(letters)
    return [] if node.nil?
    words << node.word if node.word
    queue << node
    until queue.size == 0 do
      node = queue.shift
      node.children.each do |child_node|
        word = child_node.word
        words << word unless word.nil?
        queue << child_node
      end
    end
    words
  end
end
{% endcodeblock %}

The search method maintains a list of found `words` and a `queue` for a breadth first search of the Trie. We use the `shift` and `<<` operators to get queue first-in-first-out behavior. Calling search without specifying letters will result in full search for all members in the Trie.

The full source and dictionary is available on GitHub:

https://github.com/nick-aschenbach/trie-autocomplete

*Performance*

I used a database with about 210K words and did some rough, informal calculations to compare performance between arrays, hashes and my trie implementation. The prefix search is finding all words that started with a substring. Membership is for finding one exact string. Here is what I found:


```
Prefix search (1000x repetitions)
Trie: 0.034 seconds
Array: 51.3 seconds
Hash: 91.85 seconds

Membership search (100,000x)
Trie: 0.22 seconds
Array: 1580 seconds (estimated: 10,000x took 158 seconds)
Hash: 0.027 seconds

Insertion (100x)
Trie: 88.6 seconds
Array: 0.000023 seconds
Hash: 7.69 seconds
```

Prefix search performance appears to be efficient compared to arrays and hashes. Membership search appears to be a little slower than hashes. Array membership requires a full search of the array in the worst case O(N). Hash lookup is expected constant time performance. Trie membership is O(M) where M is the number of characters in the string. Insertion performance is very slow (probably due to all of the hashes being generated with this implementation). Typical use of this data structure is for search and insertion should be relatively rare. 
]]></content>
  </entry>
  
</feed>
