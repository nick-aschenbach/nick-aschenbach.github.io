<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Games | Aschenblog]]></title>
  <link href="http://nick-aschenbach.github.io/blog/categories/games/atom.xml" rel="self"/>
  <link href="http://nick-aschenbach.github.io/"/>
  <updated>2016-01-17T17:41:27-08:00</updated>
  <id>http://nick-aschenbach.github.io/</id>
  <author>
    <name><![CDATA[Nick Aschenbach]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Arkanoid Game Levels]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2015/04/27/arkanoid-game-levels/"/>
    <updated>2015-04-27T19:12:09-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2015/04/27/arkanoid-game-levels</id>
    <content type="html"><![CDATA[{% img left /assets/2015-04-27-arkanoid-game-levels/images/arkanoid_arcadeflyer.png auto auto %} I loved playing
Arkanoid when I was a kid. I spent hours playing the game over at my friend's house when I was growing up on
the original Nintendo Entertainment System. It was rated as one of the top games after its release in 1986.

I found a great Arkanoid background map set on [NES maps](http://www.nesmaps.com/) by Rick Bruns (see below). Each
level was perfectly aligned at 192 pixels wide by 232 pixels tall. The top, left and right edges were 8 pixels. Each
brick was 16 pixels wide by 8 pixels tall. With a little math (and confirming in Photoshop), I found that the
background could support exactly 11 brick tiles wide by 28 tall.

This made the map set the perfect asset for image parsing. My plan was to take the image as input and generate
source code with level data as output. Finally, I used a 3D graphics library to render the levels in browser.

**Image Parsing**

I wanted to use the [Chunky PNG](https://github.com/wvanbergen/chunky_png) and
[Oily PNG](https://github.com/wvanbergen/oily_png) gems for image parsing. The former is a 100% Ruby implementation
for encoding and decoding PNG images with read / write access at the pixel level. The latter gem uses native C
extensions to improve encoding and decoding speed for Chunky. I used these gems on other projects with good success.

{% img /assets/2015-04-27-arkanoid-game-levels/images/arkanoid.png auto auto %}

<!-- more -->

The brick colors were consistent among all of the levels. Rick created a legend with all of the colors on one page for
convenience. I created a hash in Ruby to associate R, G, B values with a color index using Photoshop and my IDE:

{% codeblock lang:rb %}
COLOR_MAP = {
  &#8220;252,252,252&#8221; => 1, # white
  &#8220;252,116,96&#8221; => 2, # orange
  &#8220;60,188,252&#8221; => 3, # light blue
  &#8220;128,208,16&#8221; => 4, # green
  &#8220;216,40,0&#8221; => 5, # red
  &#8220;0,112,236&#8221; => 6, # blue
  &#8220;252,116,180&#8221; => 7, # pink
  &#8220;252,152,56&#8221; => 8, # yellow
  &#8220;188,188,188&#8221; => 9, # silver
  &#8220;240,188,60&#8221; => 10 # gold
}
{% endcodeblock %}

I mentioned earlier that bricks were 16 pixels x 8 pixels, however some tiles had a drop shadow of one or two pixels.
I decided to scan images for blocks of color that matched one of the keys in the hash above. I made this decision
because I needed to be able to differentiate between the background (which often had long runs of pixels) and bricks.

I stored the color of the pixel in the upper left corner of a block and checked each color against this. If a
sufficiently large block of color was found, I determined that it was a brick and returned `nil` otherwise:

{% codeblock lang:rb %}
def get_brick_color(image, x, y)
  r_initial = ChunkyPNG::Color.r(image[x, y])
  g_initial = ChunkyPNG::Color.g(image[x, y])
  b_initial = ChunkyPNG::Color.b(image[x, y])

  (0&#8230;14).each do |x_offset|
    (0&#8230;6).each do |y_offset|
      r = ChunkyPNG::Color.r(image[x + x_offset, y + y_offset])
      g = ChunkyPNG::Color.g(image[x + x_offset, y + y_offset])
      b = ChunkyPNG::Color.b(image[x + x_offset, y + y_offset])

      return nil if r != r_initial || g != g_initial || b != b_initial
    end
  end

  return r_initial, g_initial, b_initial
end
{% endcodeblock %}

My plan was to scan the 11 tile x 28 tile grid for bricks using the `get_brick_color` method. Finally,
I wrote a little code to generate Javascript code by printing to standard output. I decided to output two digit numbers
so that the grid index colors would line up because the color indexes went up to 10.

Here is the full source for the image parsing code:

{% codeblock lang:rb %}
require &#8216;oily_png&#8217;
require &#8216;awesome_print&#8217;

COLOR_MAP = {
  &#8220;252,252,252&#8221; => 1, # white
  &#8220;252,116,96&#8221; => 2, # orange
  &#8220;60,188,252&#8221; => 3, # light blue
  &#8220;128,208,16&#8221; => 4, # green
  &#8220;216,40,0&#8221; => 5, # red
  &#8220;0,112,236&#8221; => 6, # blue
  &#8220;252,116,180&#8221; => 7, # pink
  &#8220;252,152,56&#8221; => 8, # yellow
  &#8220;188,188,188&#8221; => 9, # silver
  &#8220;240,188,60&#8221; => 10 # gold
}

# Notes:
# 8 pixel border left, top and right
# brick size: 16 wide x 8 tall (including 1 px shadow)
# Each sub image size is 192, 232
def scan_grid_location(image, sheet_grid_x, sheet_grid_y)
  startx = sheet_grid_x * 192
  starty = sheet_grid_y * 232

  array = initialize_array
  # 11 columns wide x 28 rows tall
  (0..11).each do |brick_x|
    (0..28).each do |brick_y|
      color = get_brick_color(image, startx + brick_x * 16 + 8, starty + brick_y * 8 + 8)
      next if color.nil?

      color = &#8220;#{color[0]},#{color[1]},#{color[2]}&#8221;
      color_index = COLOR_MAP[color]
      raise StandardError if color_index.nil?

      array[brick_x][brick_y] = color_index
    end
  end

  array
end

# Zero out the brick array
def initialize_array
  array = []
  11.times do
    inner_array = []
    28.times do
      inner_array.push(0)
    end
    array.push(inner_array)
  end
  array
end

# Scan to ensure block is a brick
def get_brick_color(image, x, y)
  r_initial = ChunkyPNG::Color.r(image[x, y])
  g_initial = ChunkyPNG::Color.g(image[x, y])
  b_initial = ChunkyPNG::Color.b(image[x, y])

  (0&#8230;14).each do |x_offset|
    (0&#8230;6).each do |y_offset|
      r = ChunkyPNG::Color.r(image[x + x_offset, y + y_offset])
      g = ChunkyPNG::Color.g(image[x + x_offset, y + y_offset])
      b = ChunkyPNG::Color.b(image[x + x_offset, y + y_offset])

      return nil if r != r_initial || g != g_initial || b != b_initial
    end
  end

  return r_initial, g_initial, b_initial
end

arkanoid = ChunkyPNG::Image.from_file(&#8216;arkanoid.png&#8217;)

# Emit javascript code
puts &#8216;[&#8217;
(0..6).each do |y|
  (0..4).each do |x|
    level = scan_grid_location(arkanoid, x, y)

    puts &#8216;[&#8217;
    (0&#8230;28).each do |brick_y|
      print &#8216;[&#8217;
      (0&#8230;11).each do |brick_x|
        print level[brick_x][brick_y].to_s.rjust(2, &#8216;0&#8217;) + &#8216;, &#8217;
      end
      puts &#8216;],&#8217;
    end
    puts &#8216;],&#8217;
  end
end
puts &#8216;];&#8217;
{% endcodeblock %}

Here is sample output from the second map file:

{% codeblock lang:js %}
[
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [02, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [02, 03, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [02, 03, 04, 00, 00, 00, 00, 00, 00, 00, 00],
  [02, 03, 04, 06, 00, 00, 00, 00, 00, 00, 00],
  [02, 03, 04, 06, 05, 00, 00, 00, 00, 00, 00],
  [02, 03, 04, 06, 05, 02, 00, 00, 00, 00, 00],
  [02, 03, 04, 06, 05, 02, 03, 00, 00, 00, 00],
  [02, 03, 04, 06, 05, 02, 03, 04, 00, 00, 00],
  [02, 03, 04, 06, 05, 02, 03, 04, 06, 00, 00],
  [02, 03, 04, 06, 05, 02, 03, 04, 06, 05, 00],
  [09, 09, 09, 09, 09, 09, 09, 09, 09, 09, 02],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
  [00, 00, 00, 00, 00, 00, 00, 00, 00, 00, 00],
],
{% endcodeblock %}

** Visualization **

I use the [Three.js](http://threejs.org/) Javascript library for in browser 3D graphics projects. It abstracts
some of the low level details of WebGL and provides some nice primitives.

I started with some boilerplate code which I modified from Three.js:

{% codeblock lang:js %}
// Define scene, camera and renderer
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 30;
var renderer = new THREE.WebGLRenderer({antialias: true});

renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Render frames in a tight loop
var render = function() {
  requestAnimationFrame(render);
  renderer.render(scene, camera);
};

render();
{% endcodeblock %}


I defined some of the basics: a `scene`, `camera` and a `renderer`. The `render` function creates a loop that
triggers the scene to be redrawn at 60 frames per second.

I divided the drawing elements into three parts: drawing the level, drawing a wireframe box to enclose the level and
lights that provide some nice effects.

Here is the source code that describes drawing the level:

{% codeblock lang:js %}
// Draw bricks (defined in levels.js)
var draw_level = function(scene) {
  for (var i = 0; i < 28; i++) {
    for (var j = 0; j < 11; j++) {
      var color_index = level_data[level][i][j];
      if (color_index == 0) continue;

      var shininess = 10;
      if (color_index >= 9) shininess = 50; // Gold and silver

      var material = new THREE.MeshPhongMaterial({
        color: color_data[color_index],
        specular: 0x232322,
        shininess: 50
      });
      var geometry = new THREE.BoxGeometry(2, 1, 0.5);
      mesh = new THREE.Mesh(geometry, material);
      mesh.position.z = 1.5;
      mesh.position.x += j * 2.2 - 12;
      mesh.position.y += i * -1.2 + 18;
      scene.add(mesh);
      object_list.push(mesh);
    }
  }
};
{% endcodeblock %}

I defined a `level_data` array (see `level.js` below). This code was the output from the Ruby image parser described
earlier in the post. We look up the `color_index` based on where are are in the loop. If the index is zero, then we skip
that element. Otherwise, we create a new box that is twice is wide as it is tall (proportional to the 16 pixel x 8
pixel blocks from the original image).

We assign a material using Phong shading and the color defined in a `color_data` array:

{% codeblock lang:js %}
color_data = [
  0x000000,
  0xfcfcfc,
  0xfc7460,
  0x3cbcfc,
  0x80d010,
  0xd82800,
  0x0070ec,
  0xfc74b4,
  0xfc9838,
  0xbcbcbc,
  0xf0bc3c
];
{% endcodeblock %}

The index of the array corresponds to the value in the `level_data` array. We use black `0x000000` as a placeholder
color. Finally we define a mesh with the `geometry` and `material` variables. The brick position is defined by
its (i, j) position.

Here is the demo for the code ([fullscreen](/assets/2015-04-27-arkanoid-game-levels/demo/index.html)):

<iframe src="http://nick-aschenbach.github.io/assets/2015-04-27-arkanoid-game-levels/demo/index.html" width="700" height="600"></iframe>

These are the relevant full source files:

- [3d.js](/assets/2015-04-27-arkanoid-game-levels/demo/js/3d.js) - Event handling and rendering code
- [levels.js](/assets/2015-04-27-arkanoid-game-levels/demo/js/levels.js) - Level and color data]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Isometric Tiling]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2015/02/25/isometric-tile-engine/"/>
    <updated>2015-02-25T22:40:30-08:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2015/02/25/isometric-tile-engine</id>
    <content type="html"><![CDATA[In this post I share a few simple javascript examples of isometric tiling commonly used to create the illusion
of 3D graphics in games.

For years, side-scrolling video games use a projection where the camera is aligned along one of the axes. Many original
game titles like Tetris, Zelda, Super Mario Bros place the camera either above the player looking down along a
vertical axis or looking directly from the side. Basic techniques like shading and parallax scrolling (where foreground
images scroll faster than background images) help to provide a sense of depth.

{% img /assets/2015-02-25-isometric-tile-engine/images/mario.gif auto 300 %}

An [isometric projection](http://en.wikipedia.org/wiki/Isometric_projection) is a popular way of visualizing 3D objects
on a 2D screen. This involves rotating the camera 45 degrees to one side and then angling down roughly 30 degrees. This
approach is used in several role playing and strategy games (Sim City 2000 pictured below). Q*bert, released in 1982,
was perhaps one of the first games that used isometric graphics.

{% img /assets/2015-02-25-isometric-tile-engine/images/simcity.png auto 300 %}

<!-- more -->

**Drawing the Grid**

A common pattern is to use tiles that are two times wider than they are tall. Also, I find that lines with a slope of 2:1
(two pixels horizontally : one vertical) look better as pixel art. This ratio makes it relatively easy to calculate
the screen position of a tile and to find the position of the mouse over a tile.

Here is a simple example with 128x64 tiles on a HTML5 canvas:

<iframe src="http://nick-aschenbach.github.io/assets/2015-02-25-isometric-tile-engine/isometric01/index.html" width="100%" height="375"></iframe>

This snippet describes how to position the diamond / rhombus shapes in a grid
([full source](/assets/2015-02-25-isometric-tile-engine/isometric01/js/isometric.js)):

{% codeblock lang:js %}
tileColumnOffset: 64,
tileRowOffset: 32,

redrawTiles: function() {
  for(var Xi = 0; Xi < this.Xtiles; Xi++) {
    for(var Yi = 0; Yi < this.Ytiles; Yi++) {
      var offX = Xi * this.tileColumnOffset / 2 + Yi * this.tileColumnOffset / 2 + this.originX;
      var offY = Yi * this.tileRowOffset / 2 - Xi * this.tileRowOffset / 2 + this.originY;

      // Draw tile outline
      var color = '#999';
      this.drawLine(offX, offY + this.tileRowOffset / 2, offX + this.tileColumnOffset / 2, offY, color);
      this.drawLine(offX + this.tileColumnOffset / 2, offY, offX + this.tileColumnOffset, offY + this.tileRowOffset / 2, color);
      this.drawLine(offX + this.tileColumnOffset, offY + this.tileRowOffset / 2, offX + this.tileColumnOffset / 2, offY + this.tileRowOffset, color);
      this.drawLine(offX + this.tileColumnOffset / 2, offY + this.tileRowOffset, offX, offY + this.tileRowOffset / 2, color);
    }
  }
}
{% endcodeblock %}

When we use actual graphical tiles `redrawTiles`, the draw order will need to be changed so that tiles in the back
are rendered before ones in the front. Let's extend the work by adding colors, coordinates and some mouse listeners:

<iframe src="http://nick-aschenbach.github.io/assets/2015-02-25-isometric-tile-engine/isometric02/index.html" width="100%" height="375"></iframe>

Here is the salient code that handles canvas drawing
([full source](/assets/2015-02-25-isometric-tile-engine/isometric02/js/isometric.js)):

{% codeblock lang:js %}
redrawTiles: function() {
  for(var Xi = (this.Xtiles - 1); Xi >= 0; Xi&#8211;) {
    for(var Yi = 0; Yi < this.Ytiles; Yi++) {
      this.drawTile(Xi, Yi);
    }
  }
},

drawTile: function(Xi, Yi) {
  var offX = Xi * this.tileColumnOffset / 2 + Yi * this.tileColumnOffset / 2 + this.originX;
  var offY = Yi * this.tileRowOffset / 2 - Xi * this.tileRowOffset / 2 + this.originY;

  // Draw tile interior
  if( Xi == this.selectedTileX && Yi == this.selectedTileY)
    this.context.fillStyle = 'yellow';
  else
    this.context.fillStyle = 'green';
  this.context.moveTo(offX, offY + this.tileRowOffset / 2);
  this.context.lineTo(offX + this.tileColumnOffset / 2, offY, offX + this.tileColumnOffset, offY + this.tileRowOffset / 2);
  this.context.lineTo(offX + this.tileColumnOffset, offY + this.tileRowOffset / 2, offX + this.tileColumnOffset / 2, offY + this.tileRowOffset);
  this.context.lineTo(offX + this.tileColumnOffset / 2, offY + this.tileRowOffset, offX, offY + this.tileRowOffset / 2);
  this.context.stroke();
  this.context.fill();
  this.context.closePath();

  // Draw tile outline
  var color = '#999';
  this.drawLine(offX, offY + this.tileRowOffset / 2, offX + this.tileColumnOffset / 2, offY, color);
  this.drawLine(offX + this.tileColumnOffset / 2, offY, offX + this.tileColumnOffset, offY + this.tileRowOffset / 2, color);
  this.drawLine(offX + this.tileColumnOffset, offY + this.tileRowOffset / 2, offX + this.tileColumnOffset / 2, offY + this.tileRowOffset, color);
  this.drawLine(offX + this.tileColumnOffset / 2, offY + this.tileRowOffset, offX, offY + this.tileRowOffset / 2, color);

  if(this.showCoordinates) {
    this.context.fillStyle = 'orange';
    this.context.fillText(Xi + ", " + Yi, offX + this.tileColumnOffset/2 - 9, offY + this.tileRowOffset/2 + 3);
  }
},
{% endcodeblock %}

Determining the location of the mouse over a canvas tile (tileX, tileY) is determined by a few calculations in a
mouse move listener:

{% codeblock lang:js %}
$(window).on('mousemove', function(e) {
  e.pageX = e.pageX - self.tileColumnOffset / 2 - self.originX;
  e.pageY = e.pageY - self.tileRowOffset / 2 - self.originY;
  tileX = Math.round(e.pageX / self.tileColumnOffset - e.pageY / self.tileRowOffset);
  tileY = Math.round(e.pageX / self.tileColumnOffset + e.pageY / self.tileRowOffset);
{% endcodeblock %}

**Graphical Tiles**

[Open Game Art](http://opengameart.org/content/isometric-tiles) has over a hundred free tile sets worth investigating.
However, [Kenny.nl](http://www.kenney.nl/assets) provides a handful of professional looking isometric tile sets. The
quality is just excellent. He provides both individual isometric tiles and sprite sheets. XML metadata is also provided
that indicates tile location and size in the sprite sheets.

<iframe src="http://nick-aschenbach.github.io/assets/2015-02-25-isometric-tile-engine/isometric03/index.html" width="100%" height="400px"></iframe>

The code is very similar between the last two examples. A few small tweaks are needed to ensure that
tile height is consistent. Also, using tile sprite sheets would result in a performance enhancement due to the
fact that each image is loaded individually with the current implementation. However, the goal here was to keep things
as simple as possible.

The main Javascript files are:

- `isometric.js` which initializes the map and handles rendering and event handling
- `map.js` which stores a 2D array of map data and an array of image locations.

The source code and images for this are available on
[Github](https://github.com/nick-aschenbach/simple-isometric-tile-engine).

**Additional Resources**

- [Drawing Isometric Game Worlds](http://stackoverflow.com/questions/892811/drawing-isometric-game-worlds) has some
pointers on the math and layout.
- [Isometric Primer for Game Developers](http://gamedevelopment.tutsplus.com/tutorials/creating-isometric-worlds-a-primer-for-game-developers&#8211;gamedev-6511)
provides a good foundation and covers bounds detection, depth sorting and animation
- [Overviewer](https://github.com/overviewer/Minecraft-Overviewer), a tool for mapping Minecraft worlds using Google
Maps has excellent [design documentation](http://docs.overviewer.org/en/latest/design/designdoc/) that covers its
sprite rendering engine.]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Game Time]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/11/26/game-time/"/>
    <updated>2014-11-26T11:09:34-08:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/11/26/game-time</id>
    <content type="html"><![CDATA[My team laughed quite a bit recently while playing Pictionary at lunchtime over the past several weeks. We have had a few HR (not safe for work) fails in addition to several entertaining missed phrases (including `Pizza Gazebo` instead of `Pizza Hut`). We use tablets as our drawing surfaces to save paper, which introduces challenges when trying to draw rapidly. To find words, we used the [Game Gal's word generator](https://www.thegamegal.com/word-generator/).
 
I love words and decided to look at the word generator implementation to see if I could see if I could use their API to get categorized word lists. I used Chrome's POSTman tool to issue GET requests to the following URL:

<!-- more -->

&#8220;`
https://www.thegamegal.com/wordgenerator/generator.php?game=2&category=6
&#8220;`

The `2` is pictionary and `6` is for the easy category. See the `generator.js` file or look at the word generator DOM for more details. 

I decided to compile a complete list of all words, phrases, actions, characters, movies, songs, etc from the site into a tool that others can use. The GameWords gem was born ([Github](https://github.com/nick-aschenbach/game-words), [RubyGems](http://rubygems.org/gems/game_words)). This tool is both a Ruby library and has a command line interface. Below we will investigate the command line tool options:

To install the GameWords gem (which requires Ruby) from a terminal:

&#8220;`
$ gem install game_words
&#8220;`

Running the command with no options will show the help:

&#8220;`
$ gamewords
Usage: gamewords [options] game [category]
    -l, &#8211;list                       List games
    -c, &#8211;categories GAME            List categories for a GAME
    -r, &#8211;random                     Show one random word or phrase for a GAME [CATEGORY]
    -v, &#8211;version                    Show the version
    -h, &#8211;help                       Display help screen
&#8220;`

To find a Pictionary word for all categories:

&#8220;`
$ gamewords pictionary
&#8220;`

Show all words for a specific game category:

&#8220;`
$ gamewords catchphrase people
&#8220;`

Show a list of games with the `-l` option:

&#8220;`
$ gamewords -l
&#8220;`

Show a list of categories for a game via the `-c` option:

&#8220;`
$ gamewords -c pictionary
&#8220;`

Show a single random word or phrase use the `-r` option:

&#8220;`
$ gamewords -r charades actions
&#8220;`

The holidays are a great chance to catch up with family and close friends. If you like word games perhaps this library can provide some incentive to either play or write your own word games. There are almost 5,000 words, phrases, songs, movies, characters, actions and sayings.

Happy Holidays!]]></content>
  </entry>
  
</feed>
