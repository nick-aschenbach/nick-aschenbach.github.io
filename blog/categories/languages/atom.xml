<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Languages | Aschenblog]]></title>
  <link href="http://nick-aschenbach.github.io/blog/categories/languages/atom.xml" rel="self"/>
  <link href="http://nick-aschenbach.github.io/"/>
  <updated>2016-01-17T17:41:27-08:00</updated>
  <id>http://nick-aschenbach.github.io/</id>
  <author>
    <name><![CDATA[Nick Aschenbach]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[jRuby Test Drive]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2015/03/14/getting-started-with-jruby/"/>
    <updated>2015-03-14T09:09:13-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2015/03/14/getting-started-with-jruby</id>
    <content type="html"><![CDATA[After hearing about jRuby on several Ruby Rogues podcasts and reading posts about it online, I wanted to give it a shot.

Installation is super easy if you use [rvm](https://rvm.io/):

{% codeblock lang:js %}
rvm install jruby
{% endcodeblock %}

This will install several dependencies (like the patch, gawk, g++ and the JDK if you do not already have them
installed). The installation and setup took about seven minutes on a clean Ubuntu 12.04 Vagrant box I spun up for
testing purposes.

Let's say hello in irb:

{% codeblock lang:rb %}
> java.lang.System.out.println &#8216;Hello World!&#8217;
Hello World!
{% endcodeblock %}

Specifying the package is a little cumbersome. Importing the `java.lang.System` makes things a little easier:

{% codeblock lang:rb %}
> import java.lang.System
> System.out.println &#8216;Hello World!&#8217;
Hello World!
{% endcodeblock %}

<!-- more -->

jRuby provides access to Java&#8217;s rich API and large number of open source packages. The runtime performance is
approximately the same, however the memory consumption appears to be higher for jRuby programs according to a
[2014 survey](http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=jruby&lang2=yarv&data=u64q).
It should be noted that the JVM startup time is excluded in these benchmarks so as not to bias the results. However,
it is not inconsequential. I understand that JVM start time for some test suites can take several seconds for larger
projects, which can be painful when running regression tests.

One of the main drawbacks to concurrent programming in MRI Ruby is that threads cannot run in parallel. These are
are useful when blocking on input and output, for example. However, gems that use native C code can provide
multi-threading facilities (e.g. by using POSIX threads). Another issue with MRI Ruby is that a number of data
structures are not thread safe (with the exception of the `Queue` class).

jRuby provides access to `java.lang.Thread` which enables running multiple threads of execution concurrently
on multiple cores. There appear to be some notable drawbacks in jRuby. Because the code runs on the JVM, we are
precluded from using gems with native code. These gems need to be swapped out with
[alternatives](https://github.com/jruby/jruby/wiki/C-Extension-Alternatives). Another issue is that jRuby is several
versions behind MRI Ruby. The latest jRuby release at the time this was written is `1.7.19`, which was to shore up
compatibility with MRI Ruby version `1.9.3`.

Threads are much cheaper to spin up than processes. Access to native threads in jRuby may help developers to scale
applications by better utilizing the hardware. Use of multiple threads of execution is a natural fit for web servers,
which need to handle multiple client connections concurrently.

**Test Drive**

Let&#8217;s take jRuby out for a spin with a hello world example that utilizes `JFrame`:

{% codeblock lang:rb %}
import javax.swing.JButton
import javax.swing.JFrame

class HelloFrame < JFrame
  def initialize
    super('Hello')
    self.setup_interface
  end

  def setup_interface
    button = JButton.new("Hello")
    button.addActionListener do |e|
      puts 'Hello World'
    end

    self.add(button)

    self.setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)
    self.setSize(300, 200)
    self.setLocationRelativeTo(nil)
    self.setVisible(true)
  end
end

HelloFrame.new
{% endcodeblock %}

If you save this as a file called `hello.rb` then it can be run from the command line by:

{% codeblock lang:bash %}
ruby hello.rb
{% endcodeblock %}

Here is the app in action:

{% img /assets/2015-03-14-getting-started-with-jruby/images/hello.png 300 200 %}

The action listener `do ... end` Ruby syntax is quite a bit cleaner than the Java alternative using an anonymous inner
class:

{% codeblock lang:java %}
button.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
    System.out.println("Hello World");
  }
});
{% endcodeblock %}

Taking what I learned and hungry for more, I decided to write a minimal web browser using jRuby. The interface is
comprised of a `JTextField` to input the URI and a `JEditorPane` to render the HTML. In addition, I use `BorderLayout`
as the layout manager for the `JFrame`:

{% codeblock lang:rb %}
import javax.swing.JScrollPane
import javax.swing.JTextField
import javax.swing.JEditorPane
import javax.swing.JFrame
import java.awt.BorderLayout

class Browser < JFrame
  def initialize
    super('jRuby Browser')
    self.initialize_interface
  end

  def initialize_interface
    response_body = JEditorPane.new('text/html', nil)

    uri_input = JTextField.new('http://')
    uri_input.add_action_listener do |e|
      response_body.setPage(e.getActionCommand)
    end

    self.setLayout(BorderLayout.new)
    self.add(uri_input, BorderLayout::NORTH)
    self.add(JScrollPane.new(response_body))

    self.setSize(800, 600)
    self.setLocationRelativeTo(nil)
    self.setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)
    self.setVisible(true)
  end
end

Browser.new
{% endcodeblock %}

While `JEditorPane` HTML support is very limited, we are able to display the webpage data for `example.com`. I resized
the window here to show the scrollbars:

{% img /assets/2015-03-14-getting-started-with-jruby/images/browser.png 800 300 %}]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Popularity Trends in Programming Languages]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/08/02/programming-languages-popularity-trends/"/>
    <updated>2014-08-02T11:18:06-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/08/02/programming-languages-popularity-trends</id>
    <content type="html"><![CDATA[Full disclosure: I am a Ruby and Java developer. 

Everyone has their favorite pet languages (myself included) and I realize that this is a topic that evokes some feelings among my peers. In recent years, I strove to be more agnostic about tools and languages. While I try to be careful about making predictions, the languages and tools that are relevant now may fall out of favor in the industry in a few years. I'll try stick to what I discovered, but I realize that my perception is colored by my experience.

I reviewed several indexes and articles including [TIOBE](http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html), [Transparent Language Popularity Index](http://lang-index.sourceforge.net/), [IEEE Spectrum: Top Programming Languages](http://spectrum.ieee.org/static/interactive-the-top-programming-languages), [PopularitY of Programming Language Index](https://sites.google.com/site/pydatalog/pypl/PyPL-PopularitY-of-Programming-Language), [RedMonk Programming Language Rankings](http://redmonk.com/sogrady/2014/01/22/language-rankings-1-14/), [Programming Language Popularity Chart](http://langpop.corger.nl/) and [GitHub Language Trends and Fragmenting Landscape](http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/)

While there was correlation between highly ranked languages between the indexes, none of them were the same. Several metrics were used including number of open source projects, number of lines of code, number of tracked bugs / issues, number of tutorials and numbers of search engine searches. The list goes on and on. How these metrics were weighted had a big impact on the overall ranking results. 

{% img left http://dberkholz-media.redmonk.com/dberkholz/files/2014/05/github_new_users_repos_issues_multiplot_composite_simple.png 450 auto New GitHub Repos %}

In alphabetical order some of the most highly ranked languages are C, C#, C++, Java, JavaScript, Objective-C, PHP, Perl, Python, Ruby and Visual Basic. About half the indexes I reviewed had C and Java in the top two spots. 

<!-- more -->

Because there is no objective measurement of programming language popularity, the exact rank seemed less important to me than how things [change over time](http://redmonk.com/dberkholz/2014/05/02/github-language-trends-and-the-fragmenting-landscape/) (see graph). Another approach that I liked was the use of [scatter plots](http://sogrady-media.redmonk.com/sogrady/files/2014/01/lang-rank-114-wm.png).

I found Donnie Berkholz&#8217;s analysis of programming language use on GitHub particularly insightful. He looks at new GitHub repos, new issues and new users as a function of time. Before we go deeper into the numbers, it is important to mention that GitHub was embraced by the Ruby community early on and the apparent drop in Ruby projects actually indicates that GitHub was adopted by the developer community at large over the past five years. 

Overall language trends (looking at GitHub issues):

- While JavaScript issues are increasing, the trend is decelerating. It may stabilize at around 25% of total issues on GitHub
- Ruby has seen a big decline and appears to be reaching 10% of issues
- Java and PHP have stabilized at 10% of issues
- Python has dropped from 15% to about 10% of issues since 2008/2009. It&#8217;s unclear if this number has stabilized.

He also points out that C# and Objective-C are widely used, but do not show up in his data because developers from those communities have not embraced GitHub to the same degree as some others. This is corroborated by [data](http://langpop.corger.nl/) that indicates while C# is discussed widely on Stack Overflow, it is not correlated as strongly with lines of code on GitHub as are other languages like Java and JavaScript:

Language    | Stack Overflow | GitHub          | Ratio
&#8212;&#8212;&#8212;&#8211; | &#8212;&#8212;&#8212;&#8212;&#8211; | &#8212;&#8212;&#8212;&#8212;&#8212;-|&#8212;&#8212;-
C#          | 679,776        | 2,469,334,797   | 3,632
Java        | 687,426        | 7,090,897,887   | 10,315
JavaScript  | 676,383        | 15,664,918,541  | 23,160
<br/>

The ratio is the number of lines of code on GitHub relative to the number of Stack Overflow comments. All three languages have a similar number of comments on Stack, but have very different ratios. 

The article closes by suggesting that we have moved towards an increasingly fragmented programming language landscape. With the rise of domain specific languages and the increasing reliance on web technologies, it will be fascinating to see what programming languages will dominate in the future.
]]></content>
  </entry>
  
</feed>
