<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Terrain | Aschenblog]]></title>
  <link href="http://nick-aschenbach.github.io/blog/categories/terrain/atom.xml" rel="self"/>
  <link href="http://nick-aschenbach.github.io/"/>
  <updated>2015-01-29T22:41:44-08:00</updated>
  <id>http://nick-aschenbach.github.io/</id>
  <author>
    <name><![CDATA[Nick Aschenbach]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building Better Worlds With Terragen 3]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2015/01/12/building-better-worlds/"/>
    <updated>2015-01-12T21:13:04-08:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2015/01/12/building-better-worlds</id>
    <content type="html"><![CDATA[<p>For years I have been interested in modeling terrain. I wrote 2D and 3D fractal terrain generators for fun when I was in school. To help inspire a side project I am working on, I utilized an excellent rendering engine for natural environments and terrain called <a href="http://planetside.co.uk/products/terragen3">Terragen 3</a> from Planetside Software. Here are a couple of screen shots from their <a href="http://planetside.co.uk/galleries/terragen-gallery">image gallery</a>:</p>

<p><a href="/assets/2015-01-12-building-better-worlds/images/lake.jpg"><img src="/assets/2015-01-12-building-better-worlds/images/lake.jpg" width="300" title="auto" ></a>
<a href="/assets/2015-01-12-building-better-worlds/images/desert.jpg"><img src="/assets/2015-01-12-building-better-worlds/images/desert.jpg" width="300" title="auto" ></a>
<a href="/assets/2015-01-12-building-better-worlds/images/village.jpg"><img src="/assets/2015-01-12-building-better-worlds/images/village.jpg" width="300" title="auto" ></a>
<a href="/assets/2015-01-12-building-better-worlds/images/volcano.jpg"><img src="/assets/2015-01-12-building-better-worlds/images/volcano.jpg" width="300" title="auto" ></a></p>

<!-- more -->


<p>I found the <a href="http://planetside.co.uk/products/download-tg3">free version</a> fairly capable. There are some limitations over the pay version of the software that include restricting resolution, render detail and degree to which anti-aliasing is applied. However, what impressed me most is how easy it is to get started (user interface pictured below left).</p>

<p>When you load the program it creates a simple environment for you. To render this basic scene, click the <code>View-&gt;Render</code> menu. Click <code>Render</code> button and wait. On my Macbook Pro, the rendering took approximately 40 seconds (pictured below right). A shortcut for the Render command is âŒ˜R. There is a rough view in the upper right that shows an approximation of how the rendered scene will appear.</p>

<p><a href="/assets/2015-01-12-building-better-worlds/images/ui.png"><img src="/assets/2015-01-12-building-better-worlds/images/ui.png" width="300" title="auto" ></a>
<a href="/assets/2015-01-12-building-better-worlds/images/basic.jpg"><img src="/assets/2015-01-12-building-better-worlds/images/basic.jpg" width="300" title="auto" ></a></p>

<p>The node network displayed in the lower right part of the interface is a hierarchial display of the scene. This includes Renderers, Cameras and scene elements like clouds, terrain and shaders. Double clicking on the <code>Render 01</code> node in the <code>Renderers</code> pane brings up the properties (to change the resolution, etc). This is limited to a maximum of 1280x900 in the free version.</p>

<p>The same configuration page is also available via the <code>Renderers</code> button on the bar at the top of the window. Adding new elements is easy. For example, to add clouds to the scene click <code>Atmosphere</code> and then the <code>Add cloud layer</code> button. I find the 3D / Volumetric clouds to be more interesting than the 2D ones.</p>

<p>I spent some time following Vladimir Chopine&rsquo;s video tutorials on youtube. This was a good starting point for me:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/HnRFJ4Vptt8" allowfullscreen></iframe></div></p>

<p>I followed along with a couple of videos and with some trial and error created this rendering:</p>

<p><a href="/assets/2015-01-12-building-better-worlds/images/mountain.jpg"><img class="left" src="/assets/2015-01-12-building-better-worlds/images/mountain.jpg" title="auto auto" ></a></p>

<p>Here is the Terragen 3 <a href="/assets//2015-01-12-building-better-worlds/images/layered_colors3.tgd">file</a> I used to generate the above rendering. Mainly I focused on creating shaders for the elements in the scene (grass, snow, sand). I played with the atmospheric, lighting and cloud elements until I found something that I liked. The rendering took about 11 minutes to complete on my laptop.</p>

<p>Terragen supports import and export FBX, Wavefront OBJ, Lightwave LWO2 and their own native TGO format. It can also import and export heightfield / DEM formats including real geographical data from GeoTIFFs. This makes it easy to communicate with other modeling packages like Rhino, Maya, 3D Studio Max, Blender and Cinema 4D.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Time Lapse at 8,600 Feet]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/10/09/time-lapse-at-8600-feet/"/>
    <updated>2014-10-09T07:47:58-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/10/09/time-lapse-at-8600-feet</id>
    <content type="html"><![CDATA[<p>While on vacation near <a href="https://www.google.com/maps/place/Devils+Thumb+Ranch+Resort+%26+Spa/@39.9662913,-105.7840392,17z/data=!3m1!4b1!4m2!3m1!1s0x876a334c90923d2f:0xa2ca7e1ac5aa7ad9">Devil&rsquo;s Thumb Ranch</a> I decided to try some time lapse photography. I wrote a bash script that took pictures on a laptop a few years ago. I ran this script using cron, but was looking for something with finer grained control. I found a <a href="http://tenderlovemaking.com/2014/03/26/webcam-photos-with-ruby.html">Tenderlovemaking post</a> that shows how to take web cam photos using Ruby with the AVCapture framework. Note that this appears to only work on OSX.</p>

<p>I modified the script from Tenderlove&rsquo;s <code>av_capture</code> gem&rsquo;s <a href="https://github.com/tenderlove/av_capture">github page</a>:</p>

<!-- more -->


<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="nb">require</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="p">;</span><span class="n">av_capture</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;session = AVCapture::Session.new</span>
</span><span class='line'><span class="sr">dev     = AVCapture.devices.find(&amp;amp;:video?)&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">session</span><span class="o">.</span><span class="n">run_with</span><span class="p">(</span><span class="n">dev</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">connection</span><span class="o">|</span>
</span><span class='line'>  <span class="mi">10000</span><span class="o">.</span><span class="n">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;counter = i.to_s.rjust(4, &quot;0&quot;)</span>
</span><span class='line'><span class="sr">File.open(&quot;img_</span><span class="si">#{</span><span class="n">counter</span><span class="si">}</span><span class="sr">.jpg&quot;, &#39;wb&#39;) do |f|</span>
</span><span class='line'><span class="sr">  f.write connection.capture</span>
</span><span class='line'><span class="sr">end</span>
</span><span class='line'><span class="sr">sleep 5</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;  end</span>
</span><span class='line'><span class="sr">end</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>I left fill with zeros so that the files will be <code>img_0000.jpg</code>, <code>img_0001.jpg</code> &hellip; If you want to increase the number of times we take photos (let&rsquo;s call it N) then change the <code>4</code> on line 8 to be <code>log_10(N).ceil</code>. So if we want to take 15,000 photos:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;pre&gt;&lt;code&gt;counter = i.to_s.rjust(5, &quot;0&quot;)</span>
</span><span class='line'><span class="sr">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;</span><span class="sr">/pre&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Now that we ran the script and generated a ton of sequentially numbered photos, how do we turn them into a movie? I used FFMPEG on a few projects in graduate school a few years ago and figured that it would be the right tool for the job.</p>

<p>To install it on OSX (requires brew):</p>

<p><code>
brew install ffmpeg
</code></p>

<p>Now to turn the photos into a movie:</p>

<p><code>
ffmpeg -r 60 -i img_%04d.jpg output.mp4
</code></p>

<p>The <code>-r 60</code> flag sets the video frame rate to 60 frames per second.</p>

<p>I ran this script for about 3.5 hours starting in the early afternoon on October 6th facing towards Devil&rsquo;s Thumb, a local geological feature. Here is the result:</p>

<p><div class="embed-video-container"><iframe src="http://www.youtube.com/embed/k9uW1tmKZTo" allowfullscreen></iframe></div></p>

<p>I started with 30 second intervals, but found that there was too much movement between frames. I changed the script to use a 5 second delay, which seemed to result in smoother transitions. Also I used YouTube&rsquo;s image stabilization post-processing feature. This is why the video appears to pan around a little. Occasionally the web cam took pictures that appeared to be too light. These appear as a white flash in the video. I identified these and copied the next image in the sequence over the white image.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maps, Lasers and Bamboo]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/07/14/laser-etched-map-lazy-susan/"/>
    <updated>2014-07-14T22:41:29-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/07/14/laser-etched-map-lazy-susan</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/colorado-mountains.jpg" title="Snowy view towards Devil&rsquo;s Thumb Ranch" ></p>

<p>I spent a week over the winter at 8,500 feet in the mountains at Old Sky Valley Ranch near Tabernash, Colorado. It is an inspiring place and I undertook a project with fellow GIS developer Nicholas Hallahan (<a href="https://github.com/hallahan/">https://github.com/hallahan/</a> <a href="http://www.spatialdev.com/#about">http://www.spatialdev.com/#about</a>) to craft a gift for one of the ranch families.</p>

<p>The project involved quite a bit of GIS modeling and graphic design work. The spatial data was obtained from a variety of sources including the USGS National Map Viewer (<a href="http://viewer.nationalmap.gov/viewer/">http://viewer.nationalmap.gov/viewer/</a>) where we found the contour data. We also obtained some of the road, hydrology, and cadastral (building footprints) data from the Grand County, CO GIS Department (<a href="http://co.grand.co.us/170/Digital-Data-Sets">http://co.grand.co.us/170/Digital-Data-Sets</a>). Much of the fine grained details of this data were missing, such as some of the less develped roads and the precision of bends of the rivers and streams. This was achieved by hand digitizing from satellite imagery features that were missing in OpenStreetMap and then importing that final product. This part was a lot of fun, and in turn we got a new feeling and perspective of the geography of the area.</p>

<!-- more -->


<p><img class="right" src="/images/colorado-mid-scale.jpg" width="350" title="auto Mid scale map" ></p>

<p>Once all of the source data was gathered, we used ArcGIS to filter out unwanted features and narrow down the area of the data to the extent of the map we wanted to produce. The work was further cleaned up in Adobe Illustrator.</p>

<p>Although ArcGIS is well equipped to edit vector data, it focuses on this data in a geographic context, and we needed to specify details in the final, printable vector format. This is where Adobe Illustrator comes in. Here we were able to carefully specify line widths as well as place labels for these lines. The most important part of this process was separating different features into different layers that would be cut (burned) with different settings and intensities by the laser.</p>

<p>Computer Numerical Controlled (CNC) machine tools are robots that help automate the process of making custom parts. They typically involve the use of computer aided design (CAD) and computer aided manufacturing (CAM) software tools. The main benefit of CNC tools is both that they automate the manufacturing process and are precise. In recent years CNC machines have become much more affordable. For example, small CNC routers that can cut wood, plastics and light metals are commercially available for a few thousand dollars (USD).</p>

<p>Creating the lazy susan involved several steps that included both a CNC router and CNC laser. Carbonized &frac34;" thick three-ply natural bamboo plywood sheet was selected due to its light color and durability. A 17" diameter circle was cut out on a CNC router. We used ADX Portland (<a href="http://www.adxportland.com">http://www.adxportland.com</a>) for their CNC laser service (they have an 18" x 24" table). We were able to index the part on the laser table by first cutting a 17" diameter disk in a thin piece of cardboard. We could then locate the same-sized bamboo disk into the hole we cut in the cardboard.</p>

<p>CNC lasers can be configured to cut in either a vector or raster mode. Vectors cutting is best for lines and arcs that are precisely (aka mathematically) defined. Raster cutting is better for laser engraving and is ideal for filled areas and photographs. Our project required both raster and vector cut modes. The raster mode was used to fill in the lakes and the interiors of the letters. The vector mode was used for the contour lines and letter outlines.</p>

<p>Map details look best when line weights are taken into consideration. While the laser typically cuts lines the same thickness in vector mode, we found that we could cut wider lines by defocusing the laser. This was achieved by setting the Z-home position roughly 1/8" or 3/16" above the part instead of on the part. Without this hack, we would have needed to do the burning in a &ldquo;raster&rdquo; mode in which the machine burns in a pixel-based mannor similiar to what you would see with an ink jet printer. This would have taken a very long time, and we were charged by the minute.</p>

<p>To finish up the part we went back to the CNC router to pocket it out for the lazy susan mechanism. The 9" turntable was obtained from Tap Plastics (<a href="http://www.tapplastics.com/">http://www.tapplastics.com/</a>). While the pocket diameter was 9-1/16", the depth was slightly less than the height of the mechanism. This allows the turntable to support the bamboo piece up off of the table. Finally, mineral oil was used to finish the part and protect it. Mineral oil is both food safe, readily available (check your local drug store) and brings out color the natural bamboo.</p>

<p><img src="/images/lazy-susan-collage.jpg" title="Finished lazy susan" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2D Fractal Terrain Generation]]></title>
    <link href="http://nick-aschenbach.github.io/blog/2014/07/06/2d-fractal-terrain/"/>
    <updated>2014-07-06T08:26:04-07:00</updated>
    <id>http://nick-aschenbach.github.io/blog/2014/07/06/2d-fractal-terrain</id>
    <content type="html"><![CDATA[<p>A while ago I discovered a simple algorithm to generate infinite fractal terrain. One application for this is to produce mountain-like backgrounds for 2D side-scrolling video games.</p>

<p><img class="right" src="/images/fractal-2d.png" title="Evolution of a fractal mountain" ></p>

<p>This is called the midpoint displacement algorithm. It works by recursively breaking a line into smaller and smaller segments and at each step changing the Y-value up or down by a random amount. The amount of change is reduced by some amount at each step to produce a rough or smooth looking mountain scape.</p>

<p>The blue lines (pictured right) indicate the location and amount of displacement from the previous iteration.</p>

<p>Here is an outline of the algorithm:</p>

<ol>
<li>Find the midpoint for the line segment</li>
<li>Assign the midpoint to the average of the endpoints (L + R) / 2</li>
<li>Generate a random number between -1 to 1 and multiply by the displacement value. Add this to the midpoint value.</li>
<li>Recursively subdivide this line and reduce the displacement value by a fixed amount (a roughness parameter)</li>
<li>Repeat previous until fractal is sufficiently detailed</li>
</ol>


<!-- more -->


<p>Note that the roughness parameter needs to greater than zero and less than one. Higher values result in rougher terrain and lower values result in smoother terrain. Typical values may range between 0.5 to 0.75 and depend on depth of recursion.</p>

<p>Also, note that you will have to determine what sufficiently detailed means. Arrays sized 2<sup>N</sup> + 1 are typically used to represent terrain height values. A good stopping point is when all array indicies are populated with values.</p>

<p>Let&rsquo;s take a look at a Javascript implementation of the algorithm above.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">generateTerrain</span><span class="p">(</span><span class="nx">leftIndex</span><span class="p">,</span> <span class="nx">rightIndex</span><span class="p">,</span> <span class="nx">displacement</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span><span class="p">((</span><span class="nx">leftIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nx">rightIndex</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">midIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">leftIndex</span> <span class="o">+</span> <span class="nx">rightIndex</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>  <span class="kd">var</span> <span class="nx">change</span> <span class="o">=</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&amp;</span><span class="nx">ndash</span><span class="p">;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">displacement</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">terrain_array</span><span class="p">[</span><span class="nx">midIndex</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nx">terrain_array</span><span class="p">[</span><span class="nx">leftIndex</span><span class="p">]</span> <span class="o">+</span> <span class="nx">terrain_array</span><span class="p">[</span><span class="nx">rightIndex</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="nx">change</span><span class="p">;</span><span class="o">&lt;</span><span class="err">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span>  <span class="nx">displacement</span> <span class="o">=</span> <span class="nx">displacement</span> <span class="o">*</span> <span class="nx">roughness</span><span class="p">;</span>
</span><span class='line'>  <span class="nx">generateTerrain</span><span class="p">(</span><span class="nx">leftIndex</span><span class="p">,</span> <span class="nx">midIndex</span><span class="p">,</span> <span class="nx">displacement</span><span class="p">);</span>
</span><span class='line'>  <span class="nx">generateTerrain</span><span class="p">(</span><span class="nx">midIndex</span><span class="p">,</span> <span class="nx">rightIndex</span><span class="p">,</span> <span class="nx">displacement</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The if block on line two prevents infinite recursion. Also note, that we define a global array of floating point values called terrain_array. All values in the array are initialized to zero. We also defined a global variable for roughness.</p>

<p>Here is the code in action:</p>

<p><canvas id="canvas"></canvas></p>

<p>I added animation to show how easy it is to adapt this algorithm for side scrolling action. The code is available on <a href="https://github.com/nick-aschenbach/2d-fractal-terrain">github</a>.</p>

<script>
  var array_size = Math.pow(2, 9) + 1;
  var terrain_array = [];
  var roughness = 0.55;
  var initial_displacement = 50;
  var count = 0;

  $(function() {
    initializeArray();
    generateTerrain(0, array_size - 1, initial_displacement);
    drawTerrain();
  });

  function initializeArray() {
    for(var i = 0; i < array_size; i++) {
      terrain_array.push(0);
    }
  }

  function generateTerrain(leftIndex, rightIndex, displacement) {
    if((leftIndex + 1) == rightIndex) return;
    var midIndex = Math.floor((leftIndex + rightIndex) / 2);
    var change = (Math.random() * 2 - 1) * displacement;
    terrain_array[midIndex] = (terrain_array[leftIndex] + terrain_array[rightIndex]) / 2 + change;

    displacement = displacement * roughness;
    generateTerrain(leftIndex, midIndex, displacement);
    generateTerrain(midIndex, rightIndex, displacement);
  }

  function drawTerrain() {
    var canvas = $('#canvas');
    canvas.width(array_size);
    canvas.height(4 * initial_displacement);

    var context = canvas[0].getContext("2d");
    context.canvas.width  = canvas.width();
    context.canvas.height = canvas.height();

    context.fillStyle = "black";
    context.fillRect(0, 0, canvas.width(), canvas.height());

    var gradient = context.createLinearGradient(0,0,0,initial_displacement * 4);
    gradient.addColorStop(0, "purple");
    gradient.addColorStop(1, "#333");
    context.strokeStyle = 'grey';
    context.fillStyle = gradient;
    context.beginPath();
    context.lineWidth = 0.5;
    context.moveTo(i, terrain_array[count % array_size] + 2 * initial_displacement);
    for(var i = 1; i < array_size; i++) {
      context.lineTo(i, terrain_array[(count + i) % array_size] + 2 * initial_displacement);
    }
    context.lineTo(i, 4 * initial_displacement);
    context.lineTo(0, 4 * initial_displacement);
    context.closePath();

    context.fill();
    context.stroke();

    count++;
    setTimeout(drawTerrain, 30);
  }
</script>

]]></content>
  </entry>
  
</feed>
